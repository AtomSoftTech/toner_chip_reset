{
  "name": "Reset toner chip",
  "tagline": "Avices to reset your toner chip with an Arduino",
  "body": "\r\nHere are some advices to reset your toner chip with an Arduino.\r\n\r\n# Introduction\r\n\r\nSome printer toner comes with a small circuit like:\r\n\r\n![Picture of toner](images/sp112_toner.png)\r\n\r\nIn order to reuse this kind of toner, there are two steps:\r\n\r\n1. refill the toner with ink (if needed)\r\n2. reset the toner chip (or replace it)\r\n\r\nThere is [plenty of information](www.uni-kit.com/pdf/tonerrefillinstructions.pdf) explaining how to refill the\r\ntoner but little information on how to erase the toner chip.\r\n\r\nThis document deals with the second part: how to analyse the chip and\r\nreset it.\r\n\r\nIt took me a while to get everything setup and to have my toner chip\r\nreset so i would like to share this process in order to help other to\r\ndo the same on their printer.\r\n\r\nWe will go step-by-step to understand the problem, analyse the\r\ncircuit, read the chip memory and write it back so the toner can\r\nfunction again.\r\n\r\nFor more information about why manufaturer include those chips, read\r\nthe [about page](ABOUT.md).\r\n\r\n![Picture of the font circuit](images/front_circuit.jpg)\r\n\r\n# Step 0: the problem\r\n\r\nYour computer talks to your printer via a USB link (or maybe through\r\nwifi). The printer itself communicate with the toner chip via an I2C\r\nor a SPI bus.\r\n\r\n\t+------------+           +-----------+            +-------------+\r\n\t|    Host    |    USB    |           |    I2C     |    toner    |\r\n\t|  computer  | <-------> |  Printer  | <--------> |    chip     |\r\n\t|            |           |           |            |             |\r\n\t+------------+           +-----------+            +-------------+\r\n\r\nSo what we will do is to connect our Arduino directly to the toner\r\nchip like this:\r\n\r\n\t+-----------+          +-----------+\r\n\t|           |   I2C    |   toner   |\r\n\t|  Arduino  | <------> |   chip    |\r\n\t|           |          |           |\r\n\t+-----------+          +-----------+\r\n\r\n\r\nIC2 buses are very common on embedded systems. For example,\r\nsmartphones use them to connect the touchscreen or the motion sensor\r\nto the main processor chip. There is plenty of documentation, i like\r\n[this one from saleae](http://support.saleae.com/hc/en-us/articles/200730905-Learn-I2C-Inter-Integrated-Circuit).\r\n\r\nThe full specification is avavailable at: http://www.i2c-bus.org/\r\n\r\nFor your particalar printer, it might be an SPI bus instead of an I2C\r\nbus. But this does not really matter: the analysis procedure is the\r\nsame.\r\n\r\n# Step 1: the circuit\r\n\r\nThe first step is to analyse the circuit. Here you should gather as\r\nmuch information as you can:\r\n\r\n* Read the part number and search it on the Internet.\r\n* Search if other people have shared information about your printer.\r\n\r\nIn my case, the chip looked like an EEPROM memory. This is was\r\nconfirmed by two blogs discussing other model Ricoh printers:\r\n\r\n* http://www.mikrocontroller.net/topic/369267\r\n* https://esdblog.org/ricoh-sp-c250dn-laser-printer-toner-hack/\r\n\r\nI still could not find the exact EERPOM model, but it is of the 24xxx\r\nfamily.\r\n \r\n![Front chip](images/front_circuit.png)\r\n![Front chip](images/back_circuit.png)\r\n\r\nYour particular circuit will be different from this one.\r\n\r\nIf you have absolutly no idea, jump to the section: \"Bonus 1: snif the\r\nI2C commands\" at the end of this page.\r\n\r\nThe rest of the tutorial is about how to read and write this EEPROM\r\nmemory.\r\n\r\nStep 2: connect your Arduino\r\n============================\r\n\r\nDepending on the board the I2C pins are:\r\n\r\n| Board         |   I2C pins           |\r\n| :--:          | :--:                 |\r\n| Uno, Ethernet |   A4 (SDA), A5 (SCL) |\r\n| Mega2560      |   20 (SDA), 21 (SCL) |\r\n| Due           |   20 (SDA), 21 (SCL) |\r\n| Leonardo      |   2 (SDA), 3 (SCL)   |\r\n\r\nThen connect GND and VCC to 3.3V.\r\n\r\n\r\nStep 3: find the I2C clock and address\r\n======================================\r\n\r\nTo communicate on an I2C bus, we need to know the clock speed and the\r\naddress of the EEPROM.\r\n\r\nIf you know the EEPROM model from the circuit analysis, you can\r\nread the datasheet and find the clock rate and address like this:\r\n\r\nFor example the [datasheet of the component FM24C02B](datasheet/FM24C02B-04B-08B-16B.pdf)\r\nindicates an operating clock of 1MHz at 3.3V.\r\nThe datasheet indicates how to calculate the address according to the\r\nPIN A0, A1 and A2. In binary, the address is computed like this: ``1 0\r\n1 0 A2 A1 A0``.\r\n\r\nSo if the configuration is:\r\n\r\n\tA0 = 1\r\n\tA1 = 1\r\n\tA2 = 0\r\n\r\nThe address is ``1 0 1 0 0 1 1`` (83).\r\n\r\nNote: 1MHz seems to be the upper bound of the my Arduino Mega can reach.\r\nSo I just use 800 kHz, see the [full discussion](http://electronics.stackexchange.com/questions/29457/how-to-make-arduino-do-high-speed-i2c).\r\n\r\nIf you don't know the clock rate and the device address on the I2C\r\nbus, you can scan all the possible I2C addresses at different clock\r\nrate. The directory scanner have a sketch to do this. Here is the\r\noutput of the program execution on my Arduino:\r\n\r\n\tArduino I2C Scanner - 0.1.06\r\n\r\n\tScanmode:\r\n\t\ts = single scan\r\n\t\tc = continuous scan - 1 second delay\r\n\t\tq = quit continuous scan\r\n\t\td = toggle latency delay between successful tests. 0 - 5 ms\r\n\tOutput:\r\n\t\tp = toggle printAll - printFound.\r\n\t\th = toggle header - noHeader.\r\n\t\ta = toggle address range, 0..127 - 8..120\r\n\tSpeeds:\r\n\t\t0 = 50 - 800 Khz\r\n\t\t1 = 100 KHz only\r\n\t\t2 = 200 KHz only\r\n\t\t4 = 400 KHz only\r\n\t\t8 = 800 KHz only\r\n\r\n\t\t? = help - this page\r\n\r\n\tTIME\tDEC\tHEX\t\t50\t100\t200\t250\t400\t500\t800\t[KHz]\r\n\t---------------------------------------------------------------------------------------------\r\n\t2987\t0\t0x00\t\t.\t.\t.\t.\t.\t.\t.\r\n\t2990\t1\t0x01\t\t.\t.\t.\t.\t.\t.\t. \r\n\t2992\t2\t0x02\t\t.\t.\t.\t.\t.\t.\t. \r\n\t2994\t3\t0x03\t\t.\t.\t.\t.\t.\t.\t. \r\n\t2997\t4\t0x04\t\t.\t.\t.\t.\t.\t.\t. \r\n\t2999\t5\t0x05\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3002\t6\t0x06\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3004\t7\t0x07\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3007\t8\t0x08\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3009\t9\t0x09\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3012\t10\t0x0A\t\t.\t.\t.\t.\t.\t.\t. \r\n\t[...]\r\n\t3196\t80\t0x50\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3200\t81\t0x51\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3202\t82\t0x52\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3205\t83\t0x53\t\tV\tV\tV\tV\tV\tV\tV \r\n\t3207\t84\t0x54\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3210\t85\t0x55\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3212\t86\t0x56\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3215\t87\t0x57\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3218\t88\t0x58\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3220\t89\t0x59\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3223\t90\t0x5A\t\t.\t.\t.\t.\t.\t.\t. \r\n\t[...]\r\n\t3304\t120\t0x78\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3306\t121\t0x79\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3309\t122\t0x7A\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3312\t123\t0x7B\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3314\t124\t0x7C\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3317\t125\t0x7D\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3320\t126\t0x7E\t\t.\t.\t.\t.\t.\t.\t. \r\n\t3322\t127\t0x7F\t\t.\t.\t.\t.\t.\t.\t. \r\n\r\n\t1 device find in 347 milliseconds.\r\n\r\n\r\nFrom here, we know the device address on the I2C bus is 83 (0x53) and\r\nthe operating clock is anything between 50 kHz and 800 kHz.\r\n\r\n\r\nStep 4: reading the EEPROM\r\n==========================\r\n\r\nSince we know how to communicate with the chip, let's read the content\r\nof the memory. For 24xxx EEPROM, the [datasheet for FM24C02B](datasheet/FM24C02B-04B-08B-16B.pdf) explains how to complete a read operation:\r\n\r\n\tmaster send start condition\r\n\tmaster send eeprom address + read bit\r\n\tmaster send data address\r\n\tmaster send start condition\r\n\tmaster send eeprom address + read bit\r\n\tdevice respond with data\r\n\tmaster send stop condition\r\n\r\n\tSTOP condition mandatory between writes.\r\n\tWrite cycle: 5 ms.\r\n\r\nThe function \"printRandomAddress\" of the Reset.ino sketch implements\r\nthis random read operation. Once the read operation works, you can\r\nprint each bytes of the EEPROM one by one and save them in a file.\r\n\r\n```sh\r\n\t$ head dump.txt\r\n\t0x20\r\n\t0x0\r\n\t0x1\r\n\t0x3\r\n\t0x1\r\n\t0x1\r\n\t0x3\r\n\t0x0\r\n\t0x0\r\n\t0x0\r\n```\r\n\r\nNext I converted the text file into a binary format. I found binary\r\nformat easier to analyze with xxd:\r\n\r\n\t$ head -n 256 dump.txt | xargs printf \"%02x\\n\" | xxd -c 1 -p -r > dump.bin\r\n\t$ xxd dump.bin\r\n\t00000000: 2000 0103 0101 0300 0000 ffff ffff ffff   ...............\r\n\t00000010: 1504 4d47 2700 1882 0000 0000 2000 0101  ..MG'....... ...\r\n\t00000020: 5830 3235 4d34 3331 3536 3620 0045 0000  X025M431566 .E..\r\n\t00000030: 0000 0000 0000 0000 0000 0106 0000 0000  ................\r\n\t00000040: 0000 0107 0000 0000 0000 0000 0000 0000  ................\r\n\t00000050: 0000 0000 0000 0106 2000 0101 2000 0101  ........ ... ...\r\n\t00000060: 0000 0000 0000 0000 0106 0000 0000 0000  ................\r\n\t00000070: 000e 715d 1000 1427 0000 0000 0000 0000  ..q]...'........\r\n\t00000080: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t00000090: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t000000a0: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t000000b0: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t000000c0: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t000000d0: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t000000e0: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\t000000f0: ffff ffff ffff ffff ffff ffff ffff ffff  ................\r\n\r\nHere we can see:\r\n\r\n* there seems to be a header (0x0 to 0x0f),\r\n* followed by some numbers (0x10 to 0x1f),\r\n* followed by a string (X025M431566)\r\n* followed by some sparse values\r\n\r\nThis does not make much sense. The next step is to figure out what\r\nthose values are for.\r\n\r\nStep 5: understand the data\r\n===========================\r\n\r\nIn order to understand the memory layout, we have to think like a\r\ndetective.\r\n\r\nThe EEPROM is a simple data storage. The printer might wants to:\r\n\r\n* read the toner model (to check compatibility)\r\n* store the number of printed pages and/or the number of printed dot\r\n* mark is as used by a particular printer to prevent second hand market\r\n* mark the date of the first and last usage to make it out of date.\r\n* store toner capacity of page and 'dot' (can be a cound down value).\r\n\r\nThis is purely speculative at this stage.\r\n\r\nIn the search for evidences, we can capture the USB packet sent by the\r\ncomputer to the printer. Thanks to tcpdump, this is very easy (see\r\n\"Bonus 2: snif the USB packets\").\r\n\r\nMy particular printer uses \r\n[Printer Job Language: PJL](https://en.wikipedia.org/wiki/Printer_Job_Language).\r\nHere is a data transfered over USB when I print a page:\r\n\r\n\t\u001B%-12345X@PJL\r\n\t@PJL SET TIMESTAMP=2015/09/14 21:15:14\r\n\t@PJL SET FILENAME=test - Notepad\r\n\t@PJL SET COMPRESS=JBIG\r\n\t@PJL SET USERNAME=IEUser\r\n\t@PJL SET COVER=OFF\r\n\t@PJL SET HOLD=OFF\r\n\t@PJL SET PAGESTATUS=START\r\n\t@PJL SET COPIES=1\r\n\t@PJL SET MEDIASOURCE=TRAY1\r\n\t@PJL SET MEDIATYPE=PLAINRECYCLE\r\n\t@PJL SET PAPER=LETTER\r\n\t@PJL SET PAPERWIDTH=5100\r\n\t@PJL SET PAPERLENGTH=6600\r\n\t@PJL SET RESOLUTION=600\r\n\t@PJL SET IMAGELEN=691\r\n\t[... image data ... ]\r\n\t@PJL SET DOTCOUNT=10745\r\n\t@PJL SET PAGESTATUS=END\r\n\t@PJL EOJ\r\n\t\u001B%-12345X\r\n\r\nThe important piece of information are:\r\n\r\n* the DOTCOUNT value\r\n* the TIMESTAMP value\r\n\r\nOne note about dates: To implement a simple 'out of date' mechanism,\r\nyear/mount/day is enough. But if the toner needs to warm-up or cool\r\ndown hours/minutes/seconds might also required. 2016 converted to\r\nhexadecimal is 7E0. Be aware of Unix epoch format. It is well suited\r\nfor this need. Here is an example of a date in hexadecimal values:\r\n\r\n\t$ date --date='@1456056478'\r\n\tSun Feb 21 13:07:58 CET 2016\r\n\t$ echo \"obase=16; 1456056478\" | bc\r\n\t56C9A89E\r\n\r\n32 bits is enough to live until 2038, which certainly exceeded the expected\r\nlife of such product.\r\n\r\nTo recap, we can expect the following informations in the EEPROM\r\nmemory:\r\n\r\n* a standard header to verify if the EEPROM is correctly workding\r\n* a part number for model compatibility\r\n* a status/error value (to signal when the toner has caused a problem)\r\n* a 'dot' count number (and/or the number of printed pages)\r\n* a maximum 'dot' capacity (and/or the maximum number of pages to print)\r\n* a last used date field (and/or a first used data field)\r\n\r\nUnfortunatly, I was not able to figure out the memory layout but I\r\nwish you better luck! \r\n\r\nStep 6: try some changes\r\n========================\r\n\r\nIf you are lucky enough that your toner chip is still working (printing), \r\nyou can dump the content of the EEPROM before and after printing a\r\npage. This might give you clues about the memory layout.\r\n\r\nThe process is like this:\r\n\r\n* read the EEPROM content\r\n* make some changes base on an hypothesis\r\n* write the content into the EEPROM\r\n* try to print a page and restart if this does not work.\r\n\r\nIn order to speed-up the process, i directly connect my Arduino to the\r\nchip inside the printer so i do not need to manipulate the printer\r\nduring the experiments.\r\n\r\n![Picture working installation](images/final_setup.jpg)\r\n\r\nAs for me, i try a couple of random changes without success.\r\nThen i had the idea to erase all the memory except the addresses 0x0\r\nto 0x0f and it worked!\r\n\r\nAnother advantage of the binary data: with xxd you can convert the\r\nbinary data into a C header file. This C header file can be included\r\nin your program.\r\n\r\n\t$ xxd -i dump.bin | tee dump_bin.h\r\n\tunsigned char dump_bin[] = {\r\n\t  0x20, 0x00, 0x01, 0x03, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0x15, 0x04, 0x4d, 0x47, 0x27, 0x00, 0x18, 0x82,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x01, 0x58, 0x30, 0x32, 0x35,\r\n\t  0x4d, 0x34, 0x33, 0x31, 0x35, 0x36, 0x36, 0x20, 0x00, 0x45, 0x00, 0x00,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t  0x00, 0x00, 0x01, 0x06, 0x20, 0x00, 0x01, 0x01, 0x20, 0x00, 0x01, 0x01,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x00, 0x00,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x71, 0x5d, 0x10, 0x00, 0x14, 0x27,\r\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n\t  0xff, 0xff, 0xff, 0xff\r\n\t};\r\n\tunsigned int dump_bin_len = 256;\r\n\r\n\r\nStep 7: share your findings\r\n===========================\r\n\r\nCongrats! You have done some work, collected some information and get\r\na better understanding of your toner chip. Let the world know\r\nabout your findings and learn from others!\r\n\r\n\r\nBonus 1: snif the I2C commands\r\n=============================\r\n\r\nOne way to gain some insight about the memory layout, is to spy the\r\ncommunication between the printer and the toner during the printing\r\nprocessus.\r\n\r\nIn order to do so, we can use a logical analyser. This is a simple\r\nequipement that will record the logical state of the wires.\r\n\r\n\r\n\t+------------+           +-----------+            +-------------+\r\n\t|    Host    |    USB    |           |    I2C     |    toner    |\r\n\t|  computer  | <-------> |  Printer  | <--------> |    chip     |\r\n\t|            |           |           |      ^     |             |\r\n\t+------------+           +-----------+      |     +-------------+\r\n\t                                            |\r\n\t                                        logical\r\n\t                                        analyser\r\n\r\nThis can be very useful to learn:\r\n\r\n* the general properties of the communication (type of\r\n  bus, clock speed, device address).\r\n* what memory address the printer read and write\r\n\r\nThe main open source project to use logical analysers is\r\n[Sigrok](http://sigrok.org). For the list of supported analysers\r\nplease refer to [supported hardware page](https://sigrok.org/wiki/Supported_hardware).\r\n\r\nThe following pictures explain the settings:\r\n\r\n1. attach the wires to the circuit and put back the circuit on the\r\n   toner in the printer.\r\n2. connect the logical analyzer.\r\n\r\n![Picture back circuit](images/back_circuit.jpg)\r\n\r\n![Picture logical analyzer printer](images/logical_analyser.jpg)\r\n\r\nTo capture the data transfert, you can use a graphical tool\r\nlike [Pulseview](https://sigrok.org/wiki/PulseView).\r\n\r\n![Picture of Pulseview interface](pulseview/capture_eeprom.png)\r\n\r\nYou can also use the command line tool called\r\n[sigrok-cli](https://sigrok.org/wiki/Sigrok-cli) as demonstrated\r\nbellow:\r\n\r\n\r\n```sh\r\n\t$ sigrok-cli -i start_printer_failed.sr -P i2c:scl=2:sda=3,eeprom24xx\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tWarning: Slave replied, but master aborted!\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: read\r\n\tControl word\r\n\tWord address byte: 00\r\n\tSequential random read (addr=00, 128 bytes): 20 00 01 03 01 01\r\n\t03 00 00 00 FF FF FF FF FF FF 15 04 4D 47 27 00 18 82 00 00 00 00 20\r\n\t00 01 01 58 30 32 35 4D 34 33 31 35 36 36 20 00 45 00 00 00 00 00 00\r\n\t00 00 00 00 00 00 01 06 00 00 00 00 00 00 01 07 00 00 00 00 00 00 00\r\n\t00 00 00 00 00 00 00 00 00 00 00 01 06 20 00 01 01 20 00 01 01 00 00\r\n\t00 00 00 00 00 00 01 06 00 00 00 00 00 00 00 0E 73 51 10 00 14 27 00\r\n\t00 00 00 00 00 00 00\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tWord address byte: 76\r\n\tWord address\r\n\tData byte 76: 14\r\n\tData\r\n\tByte write (addr=76, 1 byte): 14\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tWord address byte: 70\r\n\tWord address\r\n\tData byte 70: 00\r\n\tData byte 71: 0E\r\n\tData byte 72: 75\r\n\tData byte 73: 45\r\n\tData\r\n\tPage write (addr=70, 4 bytes): 00 0E 75 45\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tWord address byte: 70\r\n\tWord address\r\n\tData byte 70: 00\r\n\tData byte 71: 0E\r\n\tData byte 72: 77\r\n\tData byte 73: 39\r\n\tData\r\n\tPage write (addr=70, 4 bytes): 00 0E 77 39\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tWord address byte: 77\r\n\tWord address\r\n\tData byte 77: 5A\r\n\tData\r\n\tByte write (addr=77, 1 byte): 5A\r\n\tControl code bits: 1010\r\n\tAddress bit 2: 0\r\n\tAddress bit 1: 1\r\n\tAddress bit 0: 1\r\n\tR/W bit: write\r\n\tControl word\r\n\tWord address byte: 70\r\n\tWord address\r\n\tData byte 70: 00\r\n\tData byte 71: 0E\r\n\tData byte 72: 77\r\n\tData byte 73: 8D\r\n\tData\r\n\tPage write (addr=70, 4 bytes): 00 0E 77 8D\r\n```\r\n\r\nHow to read this: one sequential read of the content of the eeprom,\r\nfollowed by a sequence of write operations: 4 byte at 0x70, 1 byte at\r\n0x76. This the printer read all the eeprom, it is difficult to figure\r\nout which address hold which information.\r\n\r\n\r\nBonus 2: snif the USB packets\r\n============================\r\n\r\nHere is an example of USB command sent by the proprietary windows\r\ndriver to the printer (captured with tcpdump when running windows\r\ninside qemu):\r\n\r\n\t\u001B%-12345X@PJL\r\n\t@PJL SET TIMESTAMP=2015/09/14 21:15:14\r\n\t@PJL SET FILENAME=test - Notepad\r\n\t@PJL SET COMPRESS=JBIG\r\n\t@PJL SET USERNAME=IEUser\r\n\t@PJL SET COVER=OFF\r\n\t@PJL SET HOLD=OFF\r\n\t@PJL SET PAGESTATUS=START\r\n\t@PJL SET COPIES=1\r\n\t@PJL SET MEDIASOURCE=TRAY1\r\n\t@PJL SET MEDIATYPE=PLAINRECYCLE\r\n\t@PJL SET PAPER=LETTER\r\n\t@PJL SET PAPERWIDTH=5100\r\n\t@PJL SET PAPERLENGTH=6600\r\n\t@PJL SET RESOLUTION=600\r\n\t@PJL SET IMAGELEN=691\r\n\t[... image data ... ]\r\n\t@PJL SET DOTCOUNT=10745\r\n\t@PJL SET PAGESTATUS=END\r\n\t@PJL EOJ\r\n\t\u001B%-12345X\r\n\r\n\r\nUsage\r\n=====\r\n\r\n```sh\r\n\t$ make\r\n\t$ make upload\r\n\t$ picocom -b 115200 /dev/ttyACM0\r\n```\r\nLinks\r\n=====\r\n\r\nBlog:\r\n\thttp://www.hobbytronics.co.uk/arduino-external-eeprom\r\n\thttp://www.hobbytronics.co.uk/eeprom-page-write\r\n\thttp://lusorobotica.com/index.php/topic,461.msg2738.html\r\n\r\nArduino:\r\n\thttps://www.arduino.cc/en/Reference/Wire\r\n\r\nTonner investigations:\r\n\thttp://www.mikrocontroller.net/topic/369267\r\n\thttps://esdblog.org/ricoh-sp-c250dn-laser-printer-toner-hack/\r\n\thttp://rumburg.org/printerhack/\r\n\r\nToner chip reset for sale:\r\n\thttp://www.aliexpress.com/item/chip-FOR-RICOH-imagio-SP-112-SF-chip-MAILING-MACHINE-printer-POSTAGE-printer-for-Ricoh-100/32261857176.html\r\n\thttp://www.ebay.com/itm/Toner-cartridge-refill-kit-for-Ricoh-Aficio-SP112-SP112SU-SP112SF-407166-non-OEM-/161312940764\r\n\r\nRicoh:\r\n\thttps://www.techdata.com/business/Ricoh/files/july2014/CurrentMSRP.pdf\r\n\thttp://support.ricoh.com/bb_v1oi/pub_e/oi/0001044/0001044844/VM1018655/M1018655.pdf\r\n\r\nDatasheets:\r\n\thttp://www.gaw.ru/pdf/Rohm/memory/br24l01.pdf\r\n\thttp://www.rinkem.com/web/userfiles/productfile/upload/201009/FM24C02B-04B-08B-16B.pdf\r\n\r\nLogical Analyser & I2C:\r\n\thttp://support.saleae.com/hc/en-us/articles/202740085-Using-Protocol-Analyzers\r\n\thttp://support.saleae.com/hc/en-us/articles/200730905-Learn-I2C-Inter-Integrated-Circuit\r\n\r\n\r\nRicoh SP112 LED\r\n===============\r\n\r\n\tLeft LED: Power Indicator\r\n\tThis indicator lights up blue when the machine is turned on.\r\n\tIt flashes when a print job is received and while printing is in progress.\r\n\r\n\tRight LED: Alert Indicator\r\n\tThis indicator lights up red when the machine runs out of paper or consumables,\r\n\twhen the paper settings do match the settings specified by the driver,\r\n\tor when other abnormalities occur.\r\n\r\n\r\n\r\nTodo\r\n====\r\n\r\n- [x] Create arduino hello world\r\n- [x] Read internal EEPROM\r\n- [x] Draw the cricuit\r\n- [x] Understand the cricuit\r\n- [x] Try I2C clock at 400kHz and 1MHz\r\n- [x] Scan for device => use MultiSpeedScanner\r\n- [x] Analyse I2C trame with a logical analyser\r\n- [x] Visualize I2C packets with pulseview\r\n- [x] Read one EEPROM datasheet\r\n- [x] Debug I2C addresses sent (1010001 and not 0101000) ~ frequence to high\r\n- [x] Verifies the timming between read and write operations (5ms)\r\n- [x] Find the exact EEPROM chip model\r\n- [x] Find the EEPROM address (0x53)\r\n- [x] Read the EPPROM chip\r\n- [x] Order sp112 reset chip from internet\r\n- [x] Analyse the EEPROM dump\r\n- [x] Make a data hypothesis\r\n- [x] Verify the write function\r\n- [x] Dump a new reset chip\r\n- [x] Write the EEPROM with a dump of a new reset chip\r\n- [x] Test with the printer\r\n- [ ] Learn about README.md format (image insertion & style)\r\n- [ ] Write an article about this\r\n\r\n\r\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by/4.0/88x31.png\" /></a><br />This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\">Creative Commons Attribution 4.0 International License</a>.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}